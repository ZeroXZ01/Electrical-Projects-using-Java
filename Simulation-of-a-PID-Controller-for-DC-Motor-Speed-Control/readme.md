# DC Motor Speed Control Simulation with PID Controller (Using Apache Commons Math ODE Solver) in Java

This project simulates the closed-loop speed control of a DC motor using a Proportional-Integral-Derivative (PID) controller. It models the electrical and mechanical dynamics of the DC motor and employs the Euler integrator from the Apache Commons Math library to numerically solve the system's differential equations. The simulation tracks a defined reference speed profile, and the actual motor speed and the control signal (armature voltage) are visualized using JFreeChart.

## Key Features

* **DC Motor Modeling:** Simulates the electrical (armature circuit) and mechanical (rotational system) components of a brushed DC motor, considering parameters such as armature resistance, inductance, back EMF constant, torque constant, moment of inertia, and viscous friction.
* **PID Controller Implementation:** Implements a standard PID control algorithm to generate the armature voltage based on the error between the reference speed and the actual motor speed. The PID controller parameters (Kp, Ki, Kd) can be tuned to achieve desired performance.
* **Reference Speed Tracking:** Simulates the motor's response to a time-varying reference speed profile.
* **Numerical Solution with Apache Commons Math:** Utilizes the `EulerIntegrator` from the Apache Commons Math library to numerically solve the first-order differential equations that describe the DC motor's dynamics.
* **Waveform Visualization:** Generates plots using JFreeChart to visualize:
    * The reference speed and the actual motor speed over time.
    * The armature voltage (control signal) applied to the motor over time.

## Equations Used in the Simulation

The simulation is based on the following fundamental equations describing the DC motor's behavior and the PID control algorithm:

**1. Electrical Equation (Armature Circuit):**
The voltage balance equation for the armature circuit is given by:
$$V_a(t) = R_a i_a(t) + L_a \frac{di_a(t)}{dt} + E_b(t)$$
where:
* $V_a(t)$ is the armature voltage (control signal).
* $R_a$ is the armature resistance.
* $i_a(t)$ is the armature current.
* $L_a$ is the armature inductance.
* $\frac{di_a(t)}{dt}$ is the rate of change of armature current.
* $E_b(t) = K_b \omega(t)$ is the back electromotive force (EMF), proportional to the motor's angular speed $\omega(t)$. $K_b$ is the back EMF constant.

**2. Mechanical Equation (Rotational System):**
The torque balance equation for the motor's rotor is given by:
$$J \frac{d\omega(t)}{dt} = T_e(t) - B \omega(t) - T_L(t)$$
where:
* $J$ is the moment of inertia of the rotor.
* $\frac{d\omega(t)}{dt}$ is the angular acceleration.
* $T_e(t) = K_t i_a(t)$ is the electromagnetic torque produced by the motor, proportional to the armature current $i_a(t)$. $K_t$ is the torque constant ($K_t = K_b$ for SI units).
* $B$ is the viscous friction coefficient.
* $T_L(t)$ is the load torque.

**3. PID Control Algorithm:**
The armature voltage $V_a(t)$ generated by the PID controller is based on the error $e(t) = \omega_{ref}(t) - \omega(t)$, where $\omega_{ref}(t)$ is the reference speed and $\omega(t)$ is the actual speed:
$$V_a(t) = K_p e(t) + K_i \int_0^t e(\tau) d\tau + K_d \frac{de(t)}{dt}$$
where:
* $K_p$ is the proportional gain.
* $K_i$ is the integral gain.
* $K_d$ is the derivative gain.

In the discrete-time implementation, the integral term is approximated by the sum of past errors, and the derivative term is approximated by the difference between the current and previous errors.

**4. Numerical Solution (Euler's Method with Apache Commons Math):**
The `EulerIntegrator` from Apache Commons Math numerically solves the first-order differential equations derived from the electrical and mechanical equations of the motor. The `MotorEquations` class implements the `FirstOrderDifferentialEquations` interface, defining the derivatives $\frac{di_a}{dt}$ and $\frac{d\omega}{dt}$ based on the current state and the applied voltage. The Euler method approximates the state at the next time step using the current state and its derivative:
$$y(t + dt) \approx y(t) + \frac{dy}{dt}(t) \cdot dt$$
where $y$ is the state vector $[i_a, \omega]^T$.

## Key Java Libraries Used

* **JFreeChart:** For creating the line charts to visualize the reference speed, actual speed, and armature voltage over time.
* **Apache Commons Math:** Specifically, the `org.apache.commons.math3.ode.FirstOrderDifferentialEquations` interface and the `org.apache.commons.math3.ode.nonstiff.EulerIntegrator` class for numerically solving the differential equations governing the DC motor's dynamics.
* **Java Collections Framework:** (`java.util.ArrayList`, `java.util.List`) for storing the simulation data (time, speed, current, voltage, reference speed).

## How to Run

1.  **Clone the Repository:** Clone this repository to your local machine.
2.  **Install JFreeChart and Apache Commons Math:** Ensure that the JFreeChart library (`jfreechart-1.5.4.jar` and `jcommon-1.0.23.jar`) and the Apache Commons Math library (`commons-math3-3.6.1.jar` or the latest stable versions) are included in your project's classpath. If you are using a build tool like Maven, the `pom.xml` file is already configured to download these dependencies.
3.  **Compile:** Compile the `DCMotorPIDControl.java` file using a Java compiler (e.g., `javac DCMotorPIDControl.java`).
4.  **Run:** Execute the `main` method of the `DCMotorPIDControl` class (e.g., `java DCMotorPIDControl`). A window will appear displaying the plots of the reference speed vs. actual speed and the armature voltage over time.

## Project Structure

* `DCMotorPIDControl.java`: Contains the main class with methods for defining motor parameters, implementing the PID control algorithm, defining the motor's differential equations within the `MotorEquations` class, performing the simulation using the Euler integrator, and creating the plots using JFreeChart.

## Further Development

This simulation can be extended in several ways:

* **More Sophisticated Motor Models:** Incorporate non-linearities such as saturation, dead zones, and more detailed electrical and mechanical parameters.
* **Advanced PID Tuning Methods:** Implement algorithms for automatically tuning the PID controller parameters.
* **Different Numerical Integration Methods:** Explore and implement other numerical ODE solvers from Apache Commons Math (e.g., Runge-Kutta methods) for potentially higher accuracy.
* **Load Torque Variations:** Simulate the motor's response to varying load torques.
* **Disturbance Rejection Analysis:** Analyze the controller's ability to reject external disturbances.
* **Graphical User Interface (GUI):** Develop a user interface to allow for easy modification of motor and controller parameters and visualization of results.

## Author

[Your Name/Organization]

## License

[Your License (e.g., MIT License, Apache License 2.0)]